{
  "timestamp": 1758747811015,
  "toolName": "searchcode",
  "totalChunks": 1,
  "chunks": [
    {
      "type": "text",
      "text": "line: startLine,\\n            description: `Complex condition detected (complexity: ${complexity})`,\\n            before: this.extractCodeSnippet(content, startLine, startLine + 2),\\n            after: '// Extract to descriptive method\\\\nif (isValidCondition()) { }',\\n            impact: 'Improves code readability and understanding',\\n            confidence: 0.7\\n          });\\n        }\\n      }\\n    });\\n  }\\n\\n  private analyzeWithRegex(content: string, suggestions: RefactoringSuggestion[], filePath: string): void {\\n    const lines = content.split('\\\\n');\\n    \\n    // Detect long functions with regex\\n    const functionPattern = /function\\\\s+(\\\\w+)|const\\\\s+(\\\\w+)\\\\s*=\\\\s*\\\\(/g;\\n    let match;\\n    \\n    while ((match = functionPattern.exec(content)) !== null) {\\n      const functionName = match[1] || match[2];\\n      const startLine = content.substring(0, match.index).split('\\\\n').length;\\n      const functionEnd = this.findFunctionEnd(content, match.index);\\n      const functionLines = content.substring(match.index, functionEnd).split('\\\\n').length;\\n      \\n      if (functionLines > 50) {\\n        suggestions.push({\\n          id: `long_function_${suggestions.length}`,\\n          type: 'extract_method',\\n          priority: 'medium',\\n          file: filePath,\\n          line: startLine,\\n          description: `Function '${functionName}' is too long (${functionLines} lines)`,\\n          before: lines.slice(startLine - 1, startLine + 4).join('\\\\n'),\\n          after: `// Refactored ${functionName}\\\\nfunction ${functionName}() {\\\\n  // Implementation\\\\n}`,\\n          impact: 'Improves readability and maintainability',\\n          confidence: 0.6\\n        });\\n      }\\n    }\\n  }\\n\\n\\n\\n  private detectLongMethodSmells(ast: any, content: string, smells: CodeSmell[], filePath: string): void {\\n    this.traverseAST(ast, (node: any) => {\\n      if (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') {\\n        const startLine = node.loc?.start?.line || 1;\\n        const endLine = node.loc?.end?.line || startLine;\\n        const lineCount = endLine - startLine + 1;\\n        \\n        if (lineCount > 30) {\\n          const functionName = node.id?.name || 'anonymous';\\n          \\n          smells.push({\\n            type: 'long_method',\\n            severity: lineCount > 100 ? 'high' : 'medium',\\n            file: filePath,\\n            line: startLine,\\n            description: `Method '${functionName}' is too long (${lineCount} lines)`,\\n            suggestion: 'Break down into smaller methods',\\n            metrics: {\\n              lines: lineCount,\\n              complexity: this.estimateComplexity(node)\\n            }\\n          });\\n        }\\n      }\\n    });\\n  }\\n\\n  private detectLargeClassSmells(ast: any, content: string, smells: CodeSmell[], filePath: string): void {\\n    this.traverseAST(ast, (node: any) => {\\n      if (node.type === 'ClassDeclaration') {\\n        const className = node.id?.name || 'anonymous';\\n        const methods = this.countClassMethods(node);\\n        const startLine = node.loc?.start?.line || 1;\\n        \\n        if (methods > 15) {\\n          smells.push({\\n            type: 'large_class',\\n            severity: methods > 25 ? 'high' : 'medium',\\n            file: filePath,\\n            line: startLine,\\n            description: `Class '${className}' has too many methods (${methods})`,\\n            suggestion: 'Consider splitting into multiple classes',\\n            metrics: {\\n              methods: methods,\\n              responsibilities: Math.ceil(methods / 5)\\n            }\\n          });\\n        }\\n      }\\n    });\\n  }\\n\\n  private detectDeepNestingSmells(ast: any, content: string, smells: CodeSmell[], filePath: string): void {\\n    this.traverseAST(ast, (node: any) => {\\n      const depth = this.calculateNestingDepth(node);\\n      if (depth > 4) {\\n        const startLine = node.loc?.start?.line || 1;\\n        \\n        smells.push({\\n          type: 'deep_nesting',\\n          severity: depth > 6 ? 'high' : 'medium',\\n          file: filePath,\\n          line: startLine,\\n          description: `Deep nesting detected (depth: ${depth})`,\\n          suggestion: 'Extract nested logic into separate methods',\\n          metrics: {\\n            depth: depth,\\n            complexity: depth * 2\\n          }\\n        });\\n      }\\n    });\\n  }\\n\\n  private detectMagicNumberSmells(content: string, smells: CodeSmell[], filePath: string): void {\\n    const magicNumberPattern = /\\\\b(?<!\\\\.)\\\\d{2,}(?!\\\\.\\\\d)\\\\b/g;\\n    const lines = content.split('\\\\n');\\n    \\n    lines.forEach((line, index) => {\\n      const matches = line.match(magicNumberPattern);\\n      if (matches && matches.length > 0) {\\n        matches.forEach(match => {\\n          if (!this.isAcceptableNumber(match)) {\\n            smells.push({\\n              type: 'magic_number',\\n              severity: 'low',\\n              file: filePath,\\n              line: index + 1,\\n              description: `Magic number '${match}' found`,\\n              suggestion: 'Replace with named constant',\\n              metrics: {\\n                value: parseInt(match),\\n                occurrences: 1\\n              }\\n            });\\n          }\\n        });\\n      }\\n    });\\n  }\\n\\n  private detectSmellsWithRegex(content: string, smells: CodeSmell[], filePath: string): void {\\n    const lines = content.split('\\\\n');\\n    \\n    // Detect long lines\\n    lines.forEach((line, index) => {\\n      if (line.length > 120) {\\n        smells.push({\\n          type: 'long_line',\\n          severity: 'low',\\n          file: filePath,\\n          line: index + 1,\\n          description: `Line is too long (${line.length} characters)`,\\n          suggestion: 'Break line into multiple lines',\\n          metrics: {\\n            length: line.length,\\n            recommended: 120\\n          }\\n        });\\n      }\\n    });\\n  }\\n\\n  // Helper methods\\n  private countClassMethods(classNode: any): number {\\n    let count = 0;\\n    if (classNode.body && classNode.body.body) {\\n      classNode.body.body.forEach((member: any) => {\\n        if (member.type === 'MethodDefinition') {\\n          count++;\\n        }\\n      });\\n    }\\n    return count;\\n  }\\n\\n  private calculateConditionComplexity(node: any): number {\\n    let complexity = 1;\\n    \\n    const countOperators = (n: any): void => {\\n      if (!n) return;\\n      \\n      if (n.type === 'LogicalExpression' && (n.operator === '&&' || n.operator === '||')) {\\n        complexity++;\\n        countOperators(n.left);\\n        countOperators(n.right);\\n      } else if (n.type === 'BinaryExpression') {\\n        complexity++;\\n      }\\n    };\\n    \\n    countOperators(node.test || node);\\n    return complexity;\\n  }\\n\\n  private calculateNestingDepth(node: any): number {\\n    let maxDepth = 0;\\n    \\n    const traverse = (n: any, depth: number): void => {\\n      if (!n || typeof n !== 'object') return;\\n      \\n      if (n.type === 'IfStatement' || n.type === 'ForStatement' || n.type === 'WhileStatement' || n.type === 'BlockStatement') {\\n        maxDepth = Math.max(maxDepth, depth);\\n        depth++;\\n      }\\n      \\n      for (const key in n) {\\n        if (key !== 'parent') {\\n          const child = n[key];\\n          if (Array.isArray(child)) {\\n            child.forEach(item => traverse(item, depth));\\n          } else if (child && typeof child === 'object') {\\n            traverse(child, depth);\\n          }\\n        }\\n      }\\n    };\\n    \\n    traverse(node, 1);\\n    return maxDepth;\\n  }\\n\\n  private estimateComplexity(node: any): number {\\n    let complexity = 1;\\n    \\n    this.traverseAST(node, (n: any) => {\\n      if (n.type === 'IfStatement' || n.type === 'ForStatement' || n.type === 'WhileStatement' || n.type === 'SwitchCase') {\\n        complexity++;\\n      }\\n    });\\n    \\n    return complexity;\\n  }\\n\\n  private extractCodeSnippet(content: string, startLine: number, endLine: number): string {\\n    const lines = content.split('\\\\n');\\n    return lines.slice(startLine - 1, endLine).join('\\\\n');\\n  }\\n\\n  private findFunctionEnd(content: string, startIndex: number): number {\\n    let braceCount = 0;\\n    let inFunction = false;\\n    \\n    for (let i = startIndex; i < content.length; i++) {\\n      const char = content[i];\\n      \\n      if (char === '{') {\\n        braceCount++;\\n        inFunction = true;\\n      } else if (char === '}') {\\n        braceCount--;\\n        if (inFunction && braceCount === 0) {\\n          return i + 1;\\n        }\\n      }\\n    }\\n    \\n    return content.length;\\n  }\\n\\n  private findDuplicateBlocks(lines: string[]): Array<{ startLine: number; lines: string[] }> {\\n    const blocks: Array<{ startLine: number; lines: string[] }> = [];\\n    const minBlockSize = 5;\\n    \\n    for (let i = 0; i < lines.length - minBlockSize; i++) {\\n      for (let j = i + minBlockSize; j < lines.length - minBlockSize; j++) {\\n        let matchLength = 0;\\n        \\n        while (i + matchLength < lines.length &&\\n               j + matchLength < lines.length &&\\n               lines[i + matchLength].trim() === lines[j + matchLength].trim() &&\\n               lines[i + matchLength].trim().length > 0) {\\n          matchLength++;\\n        }\\n        \\n        if (matchLength >= minBlockSize) {\\n          blocks.push({\\n            startLine: i + 1,\\n            lines: lines.slice(i, i + matchLength)\\n          });\\n          i += matchLength - 1;\\n          break;\\n        }\\n      }\\n    }\\n    \\n    return blocks;\\n  }\\n\\n  private isAcceptableNumber(numStr: string): boolean {\\n    const num = parseInt(numStr);\\n    // Common acceptable numbers\\n    return num === 0 || num === 1 || num === 2 || num === 10 || num === 100 || num === 1000;\\n  }\\n\\n  private sortSuggestionsByPriority(suggestions: RefactoringSuggestion[]): RefactoringSuggestion[] {\\n    const priorityWeight = { high: 3, medium: 2, low: 1 };\\n    return suggestions.sort((a, b) => {\\n      const weightDiff = priorityWeight[b.priority] - priorityWeight[a.priority];\\n      if (weightDiff !== 0) return weightDiff;\\n      return b.confidence - a.confidence;\\n    });\\n  }\\n\\n  private sortSmellsBySeverity(smells: CodeSmell[]): CodeSmell[] {\\n    const severityWeight = { high: 3, medium: 2, low: 1 };\\n    return smells.sort((a, b) => severityWeight[b.severity] - severityWeight[a.severity]);\\n  }\\n}\",\n    \"startLine\": 0,\n    \"endLine\": 1436,\n    \"score\": 0.18072481770784013\n  }\n]"
    }
  ],
  "estimatedTokens": 2723
}